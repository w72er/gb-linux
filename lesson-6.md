# Введение в скрипты bash. Планировщик задач crontab & at

## Домашнее задание

Пропускаю время с 00:06:30 по 00:33:26

## План урока

* Правила написания скриптов. Переменные.
* Условный оператор if и циклы.
* Циклы for и while.
* Регулярные выражения и утилиты для работы с регулярными выражениями.
* Планировщики сrontab и at.


## Правила написания скриптов. Переменные.

Вся сила линукс - изучив простые команды (cp, ls, mv) мы эти команды сможем
объединять в скрипты и значит оптимизировать рутины. 
Командный интерпретатор bash. Комбинация команд - скрипты. Скрипты оформляют
в виде текстовых файлов, чтобы их можно было доработать.

!shebash

Задача: создадим текстовый файл с некоторым содержимым
```shell
cat > hello.sh # hello - name, sh - команда выполняемой оболочки.
               # расширение не влияет на выполнение файла ОС linux
```

hello.sh:
```shell
# Our first script
echo 'Hello, team!'
```

```shell
bash hello.sh # Hello, team!
chmod +x hello.sh # Сделаем файл исполняемым
hello.sh # hello.sh: команда не найдена
         # Если указан относительный путь или абсолютный,
         # то по нему иначе в папках с командами
echo $PATH
# /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
# здесь нет папки /home/a
./hello.sh
/home/user/lesson6/hello.sh
```

Предположим что переносим скрипт на другую систему, и еще хуже,
в его оболочке нет программы echo. Эту проблему решает shebang,
который явно указывает, какую оболочку следует вызвать.

shebang - особая запись в начале файла указывает на то какая программа
должна обработать команды в файле.

```shell
!#/bin/superpython # - вызовет ошибку.
```

Правила написания скриптов. Переменные.

Баш - не язык программирования, а способ взаимодействия с ОС.
В баш нет различий между типами переменных. Когда мы создаем
переменную считается нашу переменную строкой. И после выполнения
оболочка его пытается привести, к другому результату.

* Переменные окружения. Создаются при входе пользователя в систему.
В таких переменных хранится вспомогательная информация
`$PWD` - текущий каталог, имя переменной без доллара, однако, когда
мы ее читаем, то ставим знак доллара. Регистр переменной важен.
* Пользовательские переменные.
`a=123` в баш нельзя слева или справа писать знаки пробелов до или после
знака равно.
`a=$(ls)` - в переменную попадут те данные которые выведет команда `ls`
* Специальные переменные. Переменные подстановки
`$0 $1 ...$9`
`$?` - статус выполнения предыдущей команды. Уверены, что предыдущая команда
выполнена до выполнения текущей.

```bash
a@md:~/projects/my/gb-linux$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
a@md:~/projects/my/gb-linux$ echo $ID

a@md:~/projects/my/gb-linux$ echo $PWD
/home/a/projects/my/gb-linux
a@md:~/projects/my/gb-linux$ a=123
a@md:~/projects/my/gb-linux$ echo $a
123
a@md:~/projects/my/gb-linux$ a = 123
a: команда не найдена
# оболочка трактует а - не переменной а командой, которой передаются
# аргументы командной строки.
a@md:~/projects/my/gb-linux$ b='first last'
a@md:~/projects/my/gb-linux$ echo $b
first last
```

```shell
a@md:~/projects/my/gb-linux$ a=2
a@md:~/projects/my/gb-linux$ b=3
a@md:~/projects/my/gb-linux$ c=a+b
a@md:~/projects/my/gb-linux$ echo $c
a+b
a@md:~/projects/my/gb-linux$ c=$a+$b
a@md:~/projects/my/gb-linux$ echo $c
2+3
# Чтобы корректно математические операции следует применять
# специальный символы $(())
a@md:~/projects/my/gb-linux$ c=$(($a+$b))
a@md:~/projects/my/gb-linux$ echo $c
5
```

Чтобы не терять время предлагает ответить на вопрос на следующем уроке.
Если хотите пользоваться bash профессионально, изучите основы, и затем
современную оболочку.

Круглые скобки одинарные - для задания переменных.
`env` - список переменных, кроме пользовательских.
`set` - выводит настолько много включая пользовательские переменные,
в которой скорее всего запутаешься.

Переменные живут втечении времени сессии.

Чтобы сбросить значение мы можем ее сделать `a=` пустой или `unset -v a`.

## Условный оператор if и циклы.

if [выражение] # один из вариантов вызова `test`
  then
     действие
  else # этот блок опциональный
    действие
fi

```shell
#!/bin/bash

a=$1 # первый параметр запуска нашего скрипта

if [ -z $a ]
  then
    # если строка пустая, то сообщаем об ошибке
    echo "Error, please use parameter"
    exit
  else
    echo $a
fi
```

Операции сравнения
`-e` истина если файл существует
`-d` 
Сравнение строк
= или ==
!=
-z - строка пуста
- - строка не пуста
сравнение целых чисел (в базовой команде тест можем сравнивать лишь целые
числа)
    
`exit 1` - полезно использовать, чтобы возвращать ошибки. И в случае ошибки
мы понимаем что команда не была выполнена в штатном режиме.

```shell
$?
0 # нет ошибок
!0 # ошибка
```

```shell
a=$1
b=$2
if [ $a -eq $b ] # команда определяет как мы сравниваем, здесь мы считаем
                 # строки числами
if [ $a = $b ] # вот теперь мы говорим что сравниваем как строки
```

## Циклы for и while.

```shell
#!/bin/bash

# for i in 1 3 5 7 # так же работает
for i in {5..1} # 5 4 3 2 1
for i in {1..5} # 1 2 3 4 5
do
  echo $i
done
```

while - пока выполняется условие выполняем
```shell
#!/bin/bash

i=1
while [ $i -lt 10 ]
do
  echo $i
  ((i+=1))
done
```

## Регулярные выражения и утилиты для работы с регулярными выражениями.

Не имеет прямой связи с linux, но мы можем использовать их в оболочке bash.

Мы можем реализовать поиск в виде программ, но регулярки дают компактный
синтаксис (прога на 20 строк пишется в 20 символов)

Регулярные выражения бывают разных диалектов:
* POSIX (базовые BRE, расширенные ERE)
* перл совместимые - получили большее распространение благодаря простоте.

Типы символов в регулярках
* обычные символы - ищем hello - то и это и есть обычные символы
* Метасимволы
** якоря - позиция в тексте (начало конец)
** сколько повторяются символы


\ - начинаются с этого символа буквенные спец символы.
С какими утилитами применем регулярки и как это делаем

Вывести все файлы с расширением `.sh`. Команда `ls -l | grep sh` не работает
если будет `sh` встречаться в имени файла, а не в расширении.

`ls -l | grep '^.*\.sh$'` после выполнения команды красным подсвечивается
что соответсвтвует совпадению с регуляркой.

! Успокаивает что будет ясно, что должно быть неясно.

Найти все имена файлов с расширением `.sh` и в именах есть или `for` или `if`.

`ls -l | grep '^.*(for|if).*\.sh$'` - проблема в том что применяем сложные
выражения, и `grep` не понимает диалект. В данном случае мы использовали PERL-
совместимые. `ls -l | grep '^.*(for|if).*\.sh$' -P`

Как понять что не написан ключ или неправильно написан шаблон?
`echo 'строка для которой точно регулярка отработает верно' | grep ...`

### sed

Потоковые редакторы используют для автоматической обработки текста. И никак
вы в пользовательском редакторе не сможете изменить, например, 20ГБ размер файл.

Поменять слово Hello на Bye
```shell
sed 's/Hello/Bye/g' hello.sh #substring g-везде
```

## awk

так же потоковый редактор с более широкими возможностями чем `sed`.

Вывести список inode и имен файлов
`ls -il | awk '{ print $1, $10}'`

## Планировщики сrontab и at.

Для выполнения некоторых задач с периодичностью используется cron
Для выполнения единоразово в будущем at

### at

`at -f /home/user/hello.sh 23:00 06/15/2021`
очень желательно задавать абсолютный путь, не потому ли что
не понятно откуда вызывать скрипт. В кроне нет переменных окружения,
которые есть в bash. Есть два способа:
* использовать абсолютный путь
* создать PATH

список запланированных команд
`atq`

### cron

минуты (0-59)
часы (0-23)
день (1-31)
месяц (1-12)


`cat /etc/crontab` 
crontab -l - пользовательские задачи смотрим с помощью этой команды
если команды не созданы, то программа предложит его создать.
* любой день любой месяц

редактировать можно с помощью `crontab -e`

Теперь демон будет отслеживать вновь созданную задачу.

Отработатнная задача попадет в эл. почту пользователя, но удобнее смотреть по
логам.

* `cat /var/log/soslog | grep -i cron` и в назначенное время выполняем команду
  и смотрим результат
* `tail -f /var/log/syslog | grep -i cron`

Практическое задание

2ю
Однострочный скрипт лучше не писать, пишем нормальный скрипт, чтобы была
понятна структура скрипта. Пишите с помощью циклов вложенных в друг друга.

3. ls -l получить только одну запись прав, задачу решить с помощью сорт и uniq

4. если хотите можете испоьзовать регулярки, а можете простейшие строки

5. не такое простое, проверяйте как оно отработает

6. tar - архивы или можете просто скопировать папку /etc/

Сдавать можно через репозиторий, или текстом.
