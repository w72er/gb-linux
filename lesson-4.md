# Загрузка ОС и процессы

* stdin, stdout, cmd params

# Вопросы по дз

как удалять пользователя из группы
```text
sudo groupadd team1
sudo useradd -m -s /bin/bash user1
sudo usermod -aG team1 user1

sudo deluser user1 team1
# the other commands
# * usermod -G []
# * gpasswd
# * deluser
```

```text
sudo useradd -m -s /bin/bash user2
sudo usermod -aG sudo user2
sudoedit /etc/sudoers
user1 ALL=/user/sbin/adduser
%sudo ALL=(ALL:ALL) NOPASSWD:ALL
```

1. Загрузка операционной системы.
2. Процесс. Управление процессами.
3. Атрибуты процессов.
4. Управление процессами.
5. Мониторинг процессов и состояния компьютера.

## Загрузка операционной системы.

1. BIOS/UEFI
2. GRUB
3. Linux kernel & initrd
4. systemd
5. terminal

1. Когда включаем систему, сначала загружается BIOS, сейчас это UEFI. В ней проходит ициализация программного обеспечения, после
2. Передается на загрузчик, который определяет какую ОС следует загрузить, если 
Для линукса мы можем выбрать ядро.
3. если это линукс то загружается ядро, оно 
4. Для того чтобы запустить процессы пользовательского окружения, сначала запускается процесс systemd
после передается управление на программу логина, и если он вводит верно, то он переводится в terminal bash, если установлена графика, то переходит в графический интерфейс.
   
## Процесс. Управление процессами.

Процесс - совокупность выполняемого кода. Потому как одна программа может порождать несколько процессов.

Состояния процесс:
* процесс работает, например, `cat` - выводит нам содержимое файла
* процесс спит, он находится в оперативной памяти, но в данный момент не выполняется.
* процесс-зомби - это не штатная ситуация - порождение некоторого сбоя. Этот процесс находится в оперативной памяти, но не спит и не 
** происходит сбой в родительском процессе, при этом дочерний не уничтожается.

## Атрибуты процессов.

PID - идентификатор процесса, по нему мы можем получить остальные атрибуты.
PPID - родительский процесс, все процессы порождены от родителя.
UID - процессы запускаются от имени пользователя.
CMD - команда запустившая процесс.

Посмотреть данные атрибуты мы можем с помощью команды `ps`. Там ключей много, нам нужно запомнить некоторые срезы ключей
`ps -ef`

Есть процесс без предка (PPID=0) - это тот самый 
[]- процессы потока ядра
пользовательские процессы, которые могут быть в том числе запущены под псевдопользователями.

Процесс `ps -ef` имеет родителя `bash`.

## Управление процессами.

### systemctl

Служит для управления и мониторинга systemd. В основном используется для работы с демонами.

1. `systemctl status` - выведет на экран состояние системы, все процессы/демоны в древовидной структуре. Перемещаться надо стрелочками
2. `systemctl` - выведет список запущенных юнитов. С точки зрения systemctl, юнитом может быть служба, точка монтирования дискового устройства.
3. `systemctl [start|stop|status|restart|reload] service_name` - restart - stop, start, при перезапуске происходит перечитка конфигурационных файлов, без перезапуска сервиса. То есть не отключаем сесиии пользователей
4. `systemctl [enable|disable] service_name` - добавить удалить службу из автозагрузки.
    
Мы не можем включить любую программу в автозапуск, можем лишь ту программу, которая написана в режиме демона.
Простой скрипт не получится так добавить в автозагрузку. Если интересна тема, то "script as service" / "manage script with systemctl" ищем в гугле.

Демон не та программа которая выполняется для конкретного пользователя, а для всей системы. Если вам нужно запустить для пользователя, то вам надо поработать с `.bashrc`

### kill

Команда служит для отправления сигналов процессами, и лишь крайняя степень - убийство процесса.

`kill -l` - список всех доступных команд

Вот зависла программа mc мы отправляем программе сигнал TERMINATION, чтобы она подчистила за собой ресурсы.
данные в файл из буферов могут не попасть, файловые системы не отмонтированы и прочее.
```text
ps -ef
# mc 88027
kill -15 88027 # ВАЖНО: ИСПОЛЬЗУЙ СНАЧАЛА -15 TERMINATE
               # ВАЖНО: НЕ ПЕРЕПУТАЙ ПРОЦЕССЫ
kill -9 88027  # ВАЖНО: ЕСЛИ НЕ ПОМОГЛО -15, ТО ТОЛЬКО ПОТОМ -9
```

### Стандартные потоки

С каждым процессом запущенным в системе есть связанные файлы.
В unix* - все есть файл. И взаимодействие осуществляется через такие структуры - файлы.

Первые три файла связанные с процессом.
0 - STDIN
1 - STDOUT
2 - STDERR

```text
nono testfile.txt
cat testfile.txt
# если же хотим работать с потоками, то мы хотим перенаправить
# данные из файла в `cat`
cat < testfile.txt

echo 'hello, team!' # выдаем на стандартный вывод.
echo 'hello, team!' > testfile.txt # перезапишем содержимое.
echo 'Bye' >> testfile.txt # допишем

# если мы хотим работать с потоком ошибок, нам нужно указывать явно
# дескриптор потока
# например, если мы выведем список файлов из /etc/*
cat /etc/*
# в содержимом и поток ошибок и поток вывода
# давайте данные из файлов, которые прочитаелись перенаправим в файл,
# а ошибки на экран
cat /etc/* 1> cat.out
cat cat.out

# а как перенаправить поток ошибок?
# Если мы перенаправим поток ошибок в файл, то консоль будет только
# с содержимым файлов, который прочитался без ошибок.
cat /etc/* 2> cat.err


# Давайте теперь перенаправим и вывод и ошибки в один файл
cat /etc/* 1> full.log 2> full.log # ОШИБКА: ошибки пропали, но в файл попал
                                   # поток вывода.
cat /etc/* 1> full.log 2>&1 # ВЕРНО: 
```

Многие сервисы порождают множество процессов, и поэтому нужно использовать killall или по одному удалять, но такой подход сейчас считается устаревшим, поэтому используйте systemctl.

### Конвейер (pipeline)

Стандартные потоки можно перенаправлять не только в файлы, но и другим процессам.
Такая возможность дает возможность составления скриптов.
`cmd1 | cmd2 | cmd3`
* Стандартный вывод команды 1 передает на стандартный ввод команды 2
* Стандартный вывод команды 2 передает на стандартный ввод команды 3

1^14^58 = продолжим

## Мониторинг процессов и состояния компьютера.
