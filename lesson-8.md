# Урок 8. Введение в docker

6:22

todo:
* софтскилы преподавателя:
  * обращает внимание на ошибку в методичке
  * неверно поставлен вопрос
* лишний клик, сократить до минимума операции

## План урока:

10-02
* Установка docker
* Обзор docker
* Управление образами и контейнерами
* Управление сетями в docker
* Обзор docker-compose

# Установка docker

Мы уже использовали решение виртуализации, но мы ставили виртуальную систему целиком.
Метод виртуализации можно рассматривать в широком смысле:
Контейнеризация — ядро ОС поддерживает несколько изолированных экземпляров
пространства пользователей вместо одного. Эти экземпляры с точки зрения
пользователя полностью идентичны отдельному экземпляру ОС.
Простыми словами, контейнеризация позволяет визуализировать процесс.

Докер виртуализирует не ОС целиком, хотя может это делать, а виртуализирует
процесс.

Докер для создания и управления контейнерами с приложениями, в том числе.

Взято из официальной документации:
```shell
apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common -y
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
apt update; apt install docker-ce -y.

# последовательность основывается на догадке: при удалении пакета, демон остался висеть.
sudo systemctl status docker
ps -ef | grep docker
sudo systemctl start docker
```

`Docker`
`Docker-service`
`Docker-client` интерфейс для взаимодействия с демоном
`Docker-hub` - удаленное хранилище образов, которые мы сможем использовать

Docker использует структурные единицы image - заготовка в которой находится информация, код,
данные, для запуска контейнера.
Registry - откуда можем взять образы (images) (docker-hub - официальное хранилище)
Container - запущенное приложение из образа.

```shell
sudo docker run hello-world
# не увидел его локально, поэтому скачал из репозитория
# это проверочных контейнер, который показывает, что докер работает корректно.
```

Уйти от использования `sudo` нужно добавить текущего пользователя в группу docker
```shell
sudo usermod -aG docker a
su - a # чтобы изменения вступили в силу
id # покажет куда входит пользователь a
```

# Обзор docker
# Управление образами и контейнерами

docker search - найти в реесте все образы с поисковой строкой.
docker pull скачать нужный образ из реестра
docker run - запустить контейнер из некоторого образа, он может не находится локально, тогда команда сама
скачает образ из регистра
docker remove - удалит контейнер.

Рассмотрим как можно виртуализирвоать nginx
```shell
# получаем множество образов, но нас интересуют только официальные.
# те что с флагом official
docker search nginx
# NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
# nginx                              Official build of Nginx.                        15051     [OK]       
# jwilder/nginx-proxy                Automated Nginx reverse proxy for docker con…   2039                 [OK]
# richarvey/nginx-php-fpm            Container running Nginx + PHP-FPM capable of…   814                  [OK]

docker pull nginx
# Создадим индексный файл приветствия, который nginx использует, если не указан путь.
sudo mkdir -p /var/www/html
cd /var/www/html
sudo nano index.html
# <h1>Hello, team!</h1>

# Теперь запустим nginx в контейнере и обращаемся к нему.
# Не упускайте из виду, что программы которые требуют дополнительных
# настроек. И поэтому контейнеры с разными параметрами могут запускаться по-разному.
# Поэтому запустим docker со специфическими параметрами для веб-серверов.
# Поскольку это сервер, то запустим его как демон '-d'
# Для того чтобы мы могли общаться с нашим контейнером необходимо пробросить порт локальной системы
# на порт контейнера
# '-p ??:??'
# Во время работы контейнера мы можем создавать данные, менять конфигурационнные файлы, загружать файлы.
# И чтобы эти данные не терялись после остановки контейнера, пробросим папки
# '-v <папка_основной системы> <папка_докера>'
docker run -d --name nginx -p 80:80 -v /var/www/html/:/usr/share/nginx/html/ nginx
# jfuiadnui8u2jndu7h2jncv8uh23jne - считается что больше в мире не будет такого идентификатора

# чтобы проверить работу веб сервиса, обратимся к нему с помощью `curl`
curl localhost
# <h1>Hello, team!</h1>
```


```shell
docker ps # список контейнеров
docker ps -a # все контейнеры, в том числе и остановленные
```

Контейнер права на запись в папку имеет?
Контейнер запускается под правами группы docker, поэтому 
```shell
ps -ef | grep docker
# root        1450       1  0 июн21 ?     00:22:04 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock

# dockerd запущен под root, значит проблем с записью не будет
```

```shell
docker ps
docker stop nginx # docker stop kjda783
docker ps -a # проверяем, что остановлен

docker rm project_nginx_1
docker rm nginx_custom
```

конфилкт по порту. В этом случае мы можем разместить наши сервера по портам: первый 80, второй 82.

### Dockerfile

Dockerfile - сценарий по сборке нашего приложения.
Если не нашли своего сценария в docker-hub, то можем написать свой.

FROM — определит базовый образ, из которого будет собираться контейнер.
MAINTAINER — сообщит контейнеру имя автора создаваемого образа.
RUN — запустит команду внутри образа. 
ADD — берёт файлы с хоста и кладёт внутрь образа. 
VOLUME — директория, которая будет подключена в контейнер.
EXPOSE — задаст порт, через который контейнер будет общаться с внешним миром. 
CMD — команда, которая будет запущена при старте контейнера из образа.

```Dockerfile
FROM ubuntu:latest # поиск на docker-hub - этот образ будет испоьзован как основа
MAINTAINER user GB
RUN apt update
RUN apt install nginx -y
VOLUVE "/var/www/html"
EXPOSE 80
CMD /usr/sbin/ngixn -g "daemon off;" # запускается nginx в режиме демона.
```

- А сборка контейнера выполняется один раз? В docker hub уже собранные контейнеры?
- Неверно поставлен вопрос, с помощью докер файла мы собираем образ (image).
 А контейнеры мы запускаем уже из образа.
 Вторая часть вопроса, опять же не верно, в docker-hub готовые образы.

```shell
docker build -t image_name . - сборка образа . - в текущей папке 
docker run --name container_name image_name - запуск контейнера из созданного образа

docker build -t ngixn_custom_image .
docker images # убедимся что образ появился.
# перед использованием 80 порта убедитесь, что на нем ничего нет.
# Или просто увидите ошибку.
docker run --name ngixn_custom -p 80:80 ngixn_custom_image
```

Версионирование образов осуществляется тэгами.
```text
docker build --help
-t, --tag list                Name and optionally a tag in the 'name:tag' format
```

# Управление сетями в docker

Рассмотрим обзорно, чтобы глубоко копнуть нужно глубокое погружение в сети.
С помощью докера мы можем создавать сети из контейнеров — эта возможность — 
основа микро сервисной архитектуры.

Веб сервер должен повышать свою пропускную способность в зависимости от нагрузки
мы можем это сделать через добавление удаление новых контейнеров веб серверов.
А как внутри одного хоста мы это сделаем?

Bridge — сети по умолчанию, аналог типа подключения NAT в VirtualBox.
Связь устанавливается через Bridge-интерфейс, который поднимается в
операционной системе при установке Docker и носит название docker0.
(`ip a | grep docker0`)
Host — с помощью этого драйвера контейнер получает доступ к собственному
интерфейсу хоста. Аналог подключения «Мост» в VirtualBox.
Macvlan - даёт контейнерам прямой доступ к интерфейсу и суб-интерфейсу (VLAN) хоста.
Overlay - позволяет строить сети на нескольких хостах с Docker.

1. docker network ls - просмотреть доступные сети 
2. docker network inspect network_name - просмотреть участников сети 
3. Доступ к приложениям, запущенным в контейнере, осуществляется через iptables.

```shell
docker network ls
# bridge
docker network inspect bridge
```

# Обзор docker-compose

Делает то же что и докер, но при этом управляет связкой контейнеров.
Мы можем делать это вручную, но зачастую связкой управлять в ручную не удобно.

Как установить смотри в методичке

docker-compose.yaml:
```yaml
version: '3' # версия синтаксиса файла конфигурации
services: # перечисляем все сервисы
  nginx: # запускаем один контейнер с nginx
    image: nginx:latest # берем последнюю версию
    ports:
      - 80:80 # проброс портов <local>:<docker>
      - 81:80 # мы не меняем <docker> порт чтобы не менять конфигурационные порты.
    volumes:
      - /var/www/html # пробрасываем папки, они могут делиться между процессами nginx.
```

```shell
# up - собрать
# -d detach, т.к. демоны
# --build - собрать
sudo docker-compose up -d --build
docker ps
```

## внутрь контейнера

главное чтобы оболочка была bash
мы перейдем в оболочку под root, и в контейнере сильно урезанная оболочка,
поэтому не все команды будут доступны. Все изменения при остановке контейнера
теряются.
docker exec -ti nginx_custom bash 



docker restart ngixn_custom
docker logs nginx_custom # в данном случае у контейнера нет логов.

docker inspect # ???

docker top nginx_custom # как мало процессов запущено в нашем контейнере

можем посмотреть историю по образу
docker history nginx_custom

остановить образ
docker stop nginx_custom
и после того как он установлен, он попадет в список всех контейнеров и потом его можно удалить.
docker rm nginx_custom
docker image rm nginx_custom

## дз

1. обязательно Ubuntu
2. учитесь на готовых решениях, затем изменяйте немного пример, и уже потом учитесь писать свои docker-compose.
чтобы nginx заработал с php устанавливается модуль php-fpm

docker дает мобильность
Чтобы попробовать решение по новой базе данных, для этого
* установить в систему
* купить в облаке
И на это можно затратить огромное количество времени, а для докер-решения просто скачать образ.
  
Докер позволяет экономить ресурсы - не надо ставить сервер, чтобы в него устанавливать ПО.

Если у кого-то есть задолженности, сдавайте через службу поддержки.
